# ПЛАН РЕАЛИЗАЦИИ ЛИНЕЙНОЙ АТАКИ (ВАРИАНТ 5)

## ЭТАП 1: ОБНОВЛЕНИЕ ЯДРА (zmak.h)
Цель: Добавить математические примитивы для линейного анализа.

- [x] **Функция четности (Parity / Dot Product):**
    - Реализовать функцию `uint8_t parity(uint16_t val)`.
    - Она должна возвращать 1, если количество единичных битов в числе нечетное, и 0, если четное.
    - Это аналог скалярного произведения векторов над полем GF(2).
    - Пример: `parity(A & X)` вычисляет бит уравнения для маски A и значения X.

- [x] **Проверка S-Box (опционально):**
    - Убедиться, что S-box тот же, что и в дифференциальной атаке (уже сделано).

## ЭТАП 2: ПРОФИЛИРОВАНИЕ / ПОИСК ЛИНЕЙНЫХ ХАРАКТЕРИСТИК (linear_search.cpp)
Цель: Найти входную маску (InputMask) и выходную маску (OutputMask), которые дают наибольшее смещение (bias) после 5 раундов.

- [x] **Структура программы:**
    - Создать новый файл `linear_search.cpp`.
    - Подключить `zmak.h`.
    
- [x] **Алгоритм поиска:**
    - Сгенерировать большое количество случайных текстов (например, 1,000,000).
    - Зашифровать их ровно на 5 раундов (используя `encryptRounds(block, 5)`).
    - Перебрать возможные входные маски `alpha` (16 бит) и выходные маски `beta` (16 бит).
      *Совет: полный перебор 65536*65536 может быть долгим. Можно ограничиться "легкими" масками (где 1-2 бита установлены) или использовать эвристику.*
    - Для каждой пары масок `(alpha, beta)` вычислить смещение:
      `count = sum(parity(alpha & P) ^ parity(beta & C_5))`
      `bias = |(count / N) - 0.5|`
    - Сохранить топ-10 пар масок с самым высоким `bias` в файл `linear_result_5_rounds.txt`.

## ЭТАП 3: ГЕНЕРАТОР "KNOWN PLAINTEXT" (generator_linear.cpp)
Цель: Создать массив данных для атаки. В отличие от дифференциальной атаки, здесь не нужны связанные пары, просто много пар (P, C).

- [x] **Создание генератора:**
    - Создать файл `generator_linear.cpp`.
    - Генерировать случайные 16-битные блоки `P` (Plaintext).
    - Шифровать их полными 6 раундами, получая `C` (Ciphertext).
    - Записывать в файл `linear_data.txt` в формате:
      `P0 P1 P2 P3  C0 C1 C2 C3`
    - Объем данных: Линейная атака требует много данных. Рекомендуется сгенерировать от 100,000 до 1,000,000 записей (в зависимости от найденного bias).

## ЭТАП 4: РЕАЛИЗАЦИЯ АТАКИ (attack_linear.cpp)
Цель: Восстановить ключ 6-го раунда, используя найденную характеристику.

- [x] **Настройка констант:**
    - В коде прописать `TARGET_MASK_IN` (alpha) и `TARGET_MASK_OUT` (beta), найденные на Этапе 2.

- [x] **Логика атаки:**
    - Загрузить данные из `linear_data.txt`.
    - Инициализировать массив счетчиков для кандидатов ключа: `scores[16]` (все нули).
    
    - Цикл перебора кандидатов ключа `k_guess` (от 0 до 15):
        - Для каждой пары `(P, C)` из файла:
            1. Выполнить частичное дешифрование одного раунда:
               `C_prev = decryptOneRound(C, k_guess)`
               (Это состояние после 5-го раунда при предположении ключа `k_guess`).
            2. Вычислить бит уравнения:
               `bit = parity(TARGET_MASK_IN & P) ^ parity(TARGET_MASK_OUT & C_prev)`
            3. Если `bit == 0`, увеличить счетчик `scores[k_guess]`.
    
    - Вычисление результата:
        - Для каждого ключа найти модуль отклонения от половины выборки:
          `bias_k = |scores[k] - (TotalPairs / 2)|`
        - Ключ с **наибольшим** отклонением (bias) — наиболее вероятный кандидат.
    
- [x] **Вывод:**
    - Сохранить отсортированный список кандидатов в `linear_key_guess.txt`.

## ЭТАП 5: СБОРКА И ЗАПУСК
- [x] make linear_search (найти маски)
- [x] make linear_generator (создать данные)
- [x] make attack_linear (взломать)
